%----------------------------------------------------------------------------
\appendix
%----------------------------------------------------------------------------
\chapter*{\texorpdfstring{\protect\hypertarget{appendix}{Függelék}}{}}\addcontentsline{toc}{chapter}{Függelék}
\setcounter{chapter}{6}  % a fofejezet-szamlalo az angol ABC 6. betuje (F) lesz
\setcounter{equation}{0} % a fofejezet-szamlalo az angol ABC 6. betuje (F) lesz

\numberwithin{equation}{section}
\numberwithin{definition}{section}
\numberwithin{conjecture}{section}
\numberwithin{lemma}{section}
\numberwithin{theorem}{section}
\numberwithin{note}{section}
\numberwithin{figure}{section}
\numberwithin{lstlisting}{section}
%\numberwithin{tabular}{section}

  %----------------------------------------------------------------------------
  \section{Számításelméleti alapok}
  %----------------------------------------------------------------------------
  \begin{definition} [$O,~\Omega,~\Theta$]
    $f,g: \mathbb{N} \rightarrow \mathbb{R}$
    \begin{itemize}
    \item \emph{ Ordó:} $f(n)=O(g(n)),~ha~ \exists c > 0,~n_{0} > 0:~|f(n)| \leq c|g(n)|,~\forall n>n_{0}.$
    \item \emph{ Omega:} $f(n)=\Omega(g(n)),~ha~ \exists c > 0,~n_{0} > 0:~|f(n)| \geq c|g(n)|,~\forall n>n_{0}$
    \item \emph{ Teta:} $f(n)=\Theta(g(n)),~ha~ f(n)=O(g(n)) \text{ és } f(n)=\Omega(g(n)),~azaz~ \exists c_{1},c_{2} > 0,~n_{0} > 0:~c_{1}|g(n)| \leq |f(n)| \leq c_{2}|g(n)|,~\forall n>n_{0}$
    \end{itemize}
  \end{definition}

  \begin{note}
    A nagy ordós jelölésből szokás kihagyni a $logn$-es szorzót, minthogy egy decimális számot mindenképpen át kell konvertálni $logn$ bitre, így egy algoritmus lépésszámánál vagy (lokális / globális) memóriaigénynél biztosan nem tudjuk megspórolni: $\tilde{O}(n)~=~O(nlogn)$.
  \end{note}

%  \begin{definition} [K-szorosan pont-összefüggő gráf]
%    Egy G gráf k-szorosan pont-összefüggő, ha tetszőleges $k$-nál kisebb elemszámú csúcshalmazát elhagyva összefüggő gráfot kapunk, és $|V(G)| \geq k$.
%  \end{definition}
%  \begin{definition} [K-szorosan él-összefüggő gráf]
%    Egy G gráf k-szorosan él-összefüggő, ha tetszőleges $k$-nál kisebb elemszámú élhalmazát elhagyva összefüggő gráfot kapunk.
%  \end{definition}

%  Két alternatív definíció:

  \begin{definition} [K-szorosan pont-összefüggő gráf]
    Egy G gráf k-szorosan pont-összefüggő, ha tetszőleges $k$-nál kisebb elemszámú csúcshalmazát elhagyva összefüggő gráfot kapunk, és $|V(G)| \geq k$.
  \end{definition}

  \begin{definition} [K-szorosan él-összefüggő gráf]
    Egy G gráf k-szorosan él-összefüggő, ha tetszőleges $k$-nál kisebb elemszámú élhalmazát elhagyva összefüggő gráfot kapunk.
  \end{definition}

  \begin{definition} [Összefüggő gráf átmérője]
    A $G$ összefüggő gráf átmérője a két legtávolabbi csúcsának távolsága, azaz az összes csúcspár közötti legrövidebb utak közül a leghosszabbnak a hossza. Jelölje $P(u, v)$ az $u$ és $v$ csúcsok közötti utak halmazát, és $l(p)$ a $p$ út hosszát, ekkor a gráf átmérője:\\
    $$D_G = \max_{u,v \in V} \min_{p \in P(u,v)} l(p)$$
  \end{definition}

  \begin{definition} [K-reguláris gráf]
    Egy irányítatlan $G~=~(V,E)$ gráfot k-regulárisnak nevezünk, ha minden csúcsa pontosan k-fokú:
    $d(v)~=~k,~\forall v~\in~V.$
  \end{definition}

%  \begin{definition} [Síkba rajzolható gráf]
%    Egy gráf síkba rajzolható, ha a pontjainak kölcsönösen egyértelműen megfeleltethetők síkbeli pontok, az éleknek pedig a megfelelő csúcsokat összekötő egyenes szakaszok úgy, hogy a különböző szakaszok legfeljebb csak a végpontjaikban találkozhatnak.
%  \end{definition}

  \begin{definition} [DAG]
    Egy irányított gráf akkor DAG (Directed Acyclic Graph), ha nem tartalmaz irányított kört.
  \end{definition}

%  \begin{definition} [Topologikus rendezés]
%    A $G=(V,E)$ egy irányított gráf. $G$ egy topologikus rendezése, a csúcsok egy olyan $v_{1},~v_{2},...,~v_{|V|}$ sorrendje, melyben $i~\rightarrow~j~\in~E$ esetén $v_i$ előbb van, mint $v_j$.
%  \end{definition}

%  \begin{theorem} [Topologikus rendezés létezése]
%    Egy irányított gráfnak akkor és csak akkor van topologikus rendezése, ha DAG.
%  \end{theorem}

  \begin{theorem} [Maximális út létezése]\label{max_route}
    Egy irányított, súlyozott gráfban akkor lehet maximális út $u$ és $v$ között, ha a gráf DAG.
  \end{theorem}

  \begin{definition} [Gráfok izomorfiája]\label{grafizo}
    A gráfizomorfizmusok gráfok közötti bijektív struktúratartó leképezések, értve ezalatt azt, hogy a függvény és az inverz függvény egyaránt szomszédos csúcsokat szomszédos csúcsokra képez le:
    Adott $G(V,E)$ és $G'(V',E')$ gráfok. Egy $f:V \rightarrow V'$ bijektív függvény gráfizomorfizmus, ha $\{u,v\}\in E \Leftrightarrow \{f(u),f(v)\}\in E'$. Ilyenkor azt mondjuk, hogy $G(V,E)$ és $G'(V',E')$ izomorf.
  \end{definition}

  \begin{definition} [Eldöntési probléma]\label{eldontesi_def}
    Egy eldöntési problémához tartozó $L$ nyelv azoknak a bemeneteknek a halmaza, amelyekre a válasz IGEN. A lehetséges bemeneteket (amik tehát vagy beletartoznak $L$-be vagy nem), szavaknak hívjuk. Egy $X$ eldöntési probléma és $x$ bemenet esetén $x~\in~X$ jelöli, hogy az $x$ bemenetre a válasz IGEN.
  \end{definition}

  \newpage

  %----------------------------------------------------------------------------
  \section{Az útvonalválasztás teljes modellje }\label{routingmodell}
  %----------------------------------------------------------------------------
  Ahhoz, hogy felépíthessük a routing teljes modelljét, a routing algebrákon (\aref{section_routingalgebrak}. rész) kívül egy routing függvényre van szükség. Ebben a modellben a csomagok (ahogyan a valóságban is) hasznos teherből (payload) és egy header-ből állnak. Ha adott az $\mathcal{A}$ routing algebra és a G gráf, akkor a policy routing függvény az $R:~ \mathbb{N} \times \mathbb{N}~\mapsto~\mathbb{N} \times \mathbb{N}$ leképezés, a csúcsok $L_{V}:~V~\mapsto~\mathbb{N}$ címkézésével és az élek $L_{E}:~E~\mapsto~\mathbb{N}$ címkézésével, a következőképpen: minden $s,~t$ pontpárra egymás után alkalmazva R-t:
  $$(h_{i+1},~l_{i+1})~=~R(v_{i},~h_{i}),~\forall i~=~1, ..., k-1$$
  megadja a preferált $p_{st}^{*}~=~(s=) v_{1}, v_{2}, ..., v_{k}(=t)$ utat $\mathcal{A}$ szerint a megfelelő $l_{i+1}~=~(v_{i},v_{i+1})$ él-címkékkel, ahol $h_{1}$ egy alkalmas kezdő header. Azt mondjuk, hogy $R$ megvalósítja az $\mathcal{A}$ policy-t $G$-n. Még néhány óvintézkedést meg kell tennünk, hogy a címkékkel nehogy több routing információt kelljen kódolni a szükségesnél, azaz $c log n$\footnote{ Ez a címek kódolásához szükséges információ.}, valamilyen alkalmas $c$ konstanssal.\\

  Ezek alapján tehát a routing a következőképpen történik: Ha egy $u$ csomópont kap egy üzenetet $h$ header-rel, akkor egyszerűen kiszámolja az $R_{u}(h)$ lokális routing függvény értékét: $R_{u}(h)~=~R(u,h)$, hogy megkapja az új header-t, $h'$-t és a kimenő portot, $l$-t. Ezután $u$ beállítja a csomag header-jének $h'$-t és továbbküldi $l$-en keresztül.
  A routing függvénnyel már könnyen megadható egy hálózat minden csomópontjának a lokális memóriaigénye ahhoz, hogy egy adott routing policy-t valósítson meg:
  \begin{definition} [Routing policy megvalósításához szükséges lokális memória]
    Az $\mathcal{A}$ routing policy megvalósításához szükséges $\mathcal{M_{\mathcal{A}}}$ lokális memória: $$\mathcal{M_{\mathcal{A}}}~=~\max_{G \in \mathcal{G}_{n}}{ \min_{R \in \mathcal{R}}{\max_{u \in V}{ \mathcal{M_{\mathcal{A}}}(R,u)}}},$$ ahol $\mathcal{M_{\mathcal{A}}}(R,u)$ az $R_{u}$ lokális routing függvény kódolásához szükséges bitek minimális száma, $\mathcal{R}$ azon policy routing függvények halmaza, melyek megvalósítják $\mathcal{A}$ policy-t valamely $G$ gráfon, és $\mathcal{G}_{n}$ az összes $n$ csúcsú gráfok halmaza.
  \end{definition}

  %----------------------------------------------------------------------------
  \section{Tételek a routing algebrák témakörében}\label{algebratetelek}
  %----------------------------------------------------------------------------
  \begin{theorem} [Tömöríthetőség 1]\label{eq:algebratetel1}
    Ha $\mathcal{A}$ algebra kiválasztó (S) és monoton (M), akkor tömöríthető.
  \end{theorem}

  \begin{theorem} [Tömöríthetőség 2]\label{eq:algebratetel2}
    Ha $\mathcal{A}$ algebra szigorúan monoton (SM), akkor nem tömöríthető.
  \end{theorem}

  Ennél egy általánosabb tétel, aminek következménye az előző tétel:
  \begin{theorem} [Tömöríthetőség 3]\label{eq:algebratetel3}
    Ha $\mathcal{A}$ algebra tartalmaz egy delimitált (D), szigorúan monoton (SM) subalgebrát, akkor $\mathcal{A}$ nem tömöríthető.
  \end{theorem}
  \newpage

  %----------------------------------------------------------------------------
  \section{A szimulátor technikai részletei}\label{simulator}
  %----------------------------------------------------------------------------
  A szimulátort Java nyelven fejlesztettem, mivel semmilyen megkötés nem volt a \aref{framework}. fejezet specifikációjában, ami alapján ne lett volna alkalmas ez a megoldás. Azért, hogy ne csak a szimulációs eredményeket tudjam felhasználni a diplomamunkában, illetve ne csak egy elméleti megoldás legyen a keretrendszerem, törekedtem a szép, tiszta, érthető kód írására. Így mellékletként ez is értékelhető, a további munka során felhasználható.\\

  A fejlesztés során kér külső függvénykönyvtárat használtam fel: a Google Guava\footnote{A Google Guava forrása: \href{https://github.com/google/guava}{https://github.com/google/guava}} 18-as verzióját az adatszerkezetek és bejárásukra, illetve a Google Gson\footnote{A Google Gson forrása: \href{https://code.google.com/p/google-gson/}{https://code.google.com/p/google-gson/}} 2.2.4-es verzióját az eredmények JSON formátumban való mentéséhez és visszaállításukhoz.

  A szimulátor alapvetően három részre tagolódik: a hálózatot leíró osztályok, az algebrákat leíró osztályok és a szimulációt futtató osztályok.\\

  A \texttt{hu/dobrei/diploma/network package}-ben vannak az adott feladathoz tartozó hálózatot leíró osztályok, jelen esetben az \texttt{Airline}, \texttt{Airport}, \texttt{Flight}, \texttt{Route} és az \texttt{OpenFlightsNetwork} osztályok.\\

  A \texttt{hu/dobrei/diploma/algebra package}-ben van az \texttt{AbstractAlgebra} absztrakt osztály és a belőle származó \texttt{BusyAirportFindingAlgebra}, \texttt{LeastHopAlgebra}, \texttt{EarlyAdopterFindingAlgebra} és a \texttt{ShortestAlgebra} osztályok.\\

  A harmadik rész a \texttt{hu/dobrei/diploma/routing package}-ben levő osztályok, melyek a szimulációért, a végeredmények elemzéséért és az eredmények fájlba mentéséért felelősek.\\

  A tervezéstől kezdve a fejlesztése során végig arra törekedtem, hogy moduláris, könnyen újrahasználható szoftvert fejlesszek, melyet később tovább lehet adni. Ennek érdekében a lehető legtisztább, legegyszerűbb megoldásokat alkalmaztam, illetve ahol csak tudtam, ragaszkodtam a clean code\footnote{Robert C. Martin: Clean Code -- A Handbook of Agile Software Craftsmanship} elveihez.\\

  Összefoglalva elmondható, hogy sikerült elérni a célt a saját fejlesztésű szimulátorral: nem kellett másik szoftver használatát megtanulnom, biztos lehetek benne, hogy az útvonalválasztási algoritmus optimálisan van megírva és az algebrák implementálása pontos és egyszerű. Emellett további speciális felhasználásra viszonylag egyszerűen lehet módosítani a meglévő kódbázist.
